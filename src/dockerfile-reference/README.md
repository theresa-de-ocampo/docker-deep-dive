# Hands-On Notes

## `.dockerignore`

- The `.dockerignore` file works by creating a file named `.dockerignore` in the **build context root**.
- Note that the build context here is the path used by docker build, not the location of the Dockerfile.

  ```bash
  docker build -f path/to/Dockerfile/dir
  ```

- In the above example, `dir` is the build context root. In other words, `.dockerignore` should be placed in the `dir` directory.

## Shell and Exec Form

The `RUN`, `CMD`, and `ENTRYPOINT` instructions all have two possible forms:

- `INSTRUCTION command param1 param2` (Shell Form)
- `INSTRUCTION ["executable", "param1", "param2"]` (Exec Form)

The exec form is preferred when you want to execute a command without involving a shell. This form avoids the need to perform shell string munging, and to invoke commands using a specific command shell. It uses a JSON array syntax, where each element in the array is a command, flag, or argument. Docker directly passes the executable and parameters to the main process without involving a shell.

The shell form is more relaxed, and emphasizes ease of use, flexibility, and readability. This form involves a shell to execute a command. The shell is responsible for for parsing and interpreting this string, which can sometimes lead to unexpected behavior if the string contains special charaters or complex syntax.

### Shell Features

- The main thing you lose with the exec form is all the useful shell features: sub commands, pipping output, chaining commands, I/O redirection, etc. These kinds of commands are only possible with the shell form.

  ```bash
  FROM ubuntu:latest

  # Shell: run a speed test
  RUN apt-get update \
  && apt-get install -y wget \
  && wget -O /dev/null http://speedtest.wdc01.softlayer.com/downloads/test10.zip \
  && rm -rf /var/lib/apt/lists/*

  # Shell: output the default shell location
  CMD which $(echo $0)
  ```

- In the shell form, commands will inherit environment variables from shell, such as `$HOME` and `$PATH`. However, both forms behave the same when it comes to environment variables set by the `ENV` instruction.

### Signal Trapping

Most shells do not forward process signals to child processes, which means `SIGINT` generated by pressing `CTRL + C` may not stop a child process.

### Recommended Forms

- `RUN` - shell form because of the shell features.
- `ENTRYPOINT` - exec form because of signal trapping.
- `CMD` - exec form because of signal trapping.

## `COPY` Instruction

- The Dockerfile `COPY` command also cares about the presence of the trailing slash, using it to determine whether the destination should be considered a file or directory.
- If `<src>` is a directory, the entire contents of the directory are copied.

## `ADD` Instruction

Go to [playground](./add-demo/Dockerfile).

- Copies new files, directories, or remote file URLs from `<src>`, and adds them to the filesystem of the image at path `<dest>`.
- `COPY` is the same as `ADD` without the tar, and remote URL handling.
- All new files and directories are created with a UID and GID of 0, unless the optional `--chown` flag specifies a given username, groupname, or UID/GUID combination to request specific ownership of the content added.
- Providing a username without groupname or a UID without GID will use the same numeric UID as the GID.

  ```
  ADD [--chown=<user>:<group>] <src> <dest>
  ADD --chown=55:mygroup files* /somedir/
  ADD --chown=1 files* /somedir/
  ADD --chown=myuser:mygroup --chmod=655 files* /somedir/
  ```

### `chown` Command

- An abbreviation of _change ownership_.
- The `chown` and `chmod` features are only supported on Dockerfiles used to build Linux containers.

## `CMD` vs `ENTRYPOINT` Instructions

From [Abhinav Dubey's blog post](https://devtron.ai/blog/cmd-and-entrypoint-differences/).

Both instructions are used to specify the programs/commands to execute while initializing a container from a Docker image.

- `CMD` commands are ignored by daemon when there are parameters stated in the `docker run` command
- `ENTRYPOINT` instructions are not ignored, but instead are appended as command line parameters by treating those as arguments of the command.

### `CMD`

Sets the default command.

There can only be one `CMD` instruction in a Dockerfile. If you list more than one `CMD`, only the last one takes effect.

Go to [playground](./cmd-vs-entrypoint/Dockerfile).

```bash
$ docker build -t hands-on:v2 -f Dockerfile-CMD .

$ docker run hands-on:v2
My name is Teriz

$ docker run hands-on:v2 echo "Hi, I am Teriz"
Hi, I am Teriz

$ docker run hands-on:v2 printenv
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=d16c7ca2c226
HOME=/root
```

### `ENTRYPOINT`

Sets the default executable.
By opting for this instruction method, you imply that the container is specifically built for certain use-cases where command should not be overridden.

```bash
$ docker build -t hands-on:v3 -f Dockerfile-ENTRYPOINT .

$ docker run hands-on:v3
My name is Teriz

$ docker run hands-on:v3 De Ocampo
My name is Teriz De Ocampo

$ docker run hands-on:v3 printenv
My name is Teriz printenv
```

The default nature of `ENTRYPOINT` in Dockerfile is not to be overriden by parameters passed in command, but with some explicit docker flags, it can be overrided.

```bash
$ docker run --entrypoint printenv hands-on:v3
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=b295561b3b36
HOME=/root
```

The command passed in `--entrypoint` argument is temporary and once you exit out of the container and run the container again it would take the default `ENTRYPOINT` instructions if `--entrypoint` is not passed explicitly.

### Using `ENTRYPOINT` and `CMD` Together

There are fundamental differences between `ENTRYPOINT` and `CMD` but there can be many situations in which combining both would be the best solution for the Docker container. In such cases, the executable is defined with the `ENTRYPOINT`, while `CMD` specifies the default parameter.

When using both `ENTRYPOINT` and `CMD`, keep them in exec form.

```bash
$ docker build -t hands-on:v4 -f Dockerfile-BOTH .

$ docker run hands-on:v4
Hello! My name is Teriz

$ docker run hands-on:v4 @teriz_de_ocampo
Hello! @teriz_de_ocampo
```

### Usecases

Prefer `ENTRYPOINT` to `CMD` when building executable Docker images, and you need this command to be always executed.

Use `CMD` if you need to provide extra default arguments that could be overwritten from the command line when the docker container runs.

It's not necessary to use both commands together, try to find your own use-case while building the Dockerfile.
